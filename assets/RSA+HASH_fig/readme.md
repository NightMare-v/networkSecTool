[toc]

## 1.作业基本信息



| 这个作业的目标       | 1.实现Github上提交文件<br>2.接口的导入及其使用<br>3.文件格式的规范化 |
| -------------------- | ------------------------------------------------------------ |
| Github仓库           | *[仓库链接](http://10.21.4.83:81/3120005069/ns/-/tree/main/)*      |
| 其他参考文献         | ...|



## 2.计算模块接口的设计与实现过程

### 2.1 问题需求

> 题目：编程，利用RSA， Hash 实验数字签名和验证。 
> 1. 选择语言提供的Hash函数，计算数据的Hash值 
> 2. 用私钥对 Hash值 进行签名， 
> 3. 用公钥对签名值进行验证。 
> 4. 网上搜集资料，分析并解释 《中华人民共和国电子签名法(2019修正)》修改的内容。md格式，用git管理。

### 2.2 设计思路

#### 2.2.1 原理与理论基础

RSA公开密钥密码体制的原理是：根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥.

RSA算法的具体描述在此省略.

散列函数（或散列算法，又称哈希函数，英语：Hash Function）是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹.

在本题中采用的散列算法为MD5.

***1. RSA加密过程简述***

A和B进行加密通信时,B首先要生成一对密钥。一个是公钥，给A，B自己持有私钥。A使用B的公钥加密要加密发送的内容，然后B在通过自己的私钥解密内容

2. 假设A要想B发送消息，A会先计算出消息的消息摘要，然后使用自己的私钥加密这段摘要加密，最后将加密后的消息摘要和消息一起发送给B，被加密的消息摘要就是“签名”。

B收到消息后，也会使用和A相同的方法提取消息摘要，然后使用A的公钥解密A发送的来签名，并与自己计算出来的消息摘要进行比较。如果相同则说明消息是A发送给B的，同时，A也无法否认自己发送消息给B的事实。

其中，A用自己的私钥给消息摘要加密成为“签名”；B使用A的公钥解密签名文件的过程，就叫做“验签”。

3. 签名过程

1）A提取消息m的消息摘要h(m),并使用自己的私钥对摘要h(m)进行加密,生成签名s

2）A将签名s和消息m一起,使用B的公钥进行加密,生成密文c,发送给B。

具体：

+ A计算消息m的消息摘要,记为 h(m)

+ A使用私钥(n,d)对h(m)加密，生成签名s ,s满足：`s=(h(m))^d mod `;

由于A是用自己的私钥对消息摘要加密，所以只用使用s的公钥才能解密该消息摘要，这样A就不可否认自己发送了该消息给B。

A发送消息和签名(m,s)给B。

4. 验证过程

1）B接收到密文c,使用自己的私钥解密c得到明文m和数字签名s

2）B使用A的公钥解密数字签名s解密得到H(m).

3）B使用相同的方法提取消息m的消息摘要h(m)

4）B比较两个消息摘要。相同则验证成功;不同则验证失败。

具体：

1.B计算消息m的消息摘要,记为h(m);

2.B使用A的公钥(n,e)解密s,得到 `H(m) = s^e mod n`;

3.B比较H(m)与h(m),相同则证明


#### 2.2.2 内容与实现过程

1. 通过MD5算法计算数据散列值，在此采用以下数据散列值进行计算。

<img src="F:\learning\_networkSecurity\RSA_Hash_fig\Hash1notchanged1.png" alt="Hash1notchanged1" style="zoom:50%;" />

2. 由于数据散列值对于本题中的算法数据要求可能过大，在此选用前五位散列值进行计算，即`25f9e`
3. 本题中选用加密算法为RSA算法，采用 `p=6007`, `q=360089`, `e=795479`
4. 求出私钥 `d=1026474959`
5. 在此将散列值化为ASCII，方便后续计算，并对ASCII进行了一定处理.

```python
    msg = map(ord,"25f9e")
    msg = list(map(lambda x:str(x-30),list(msg)))
    msg = ''.join(msg)
    msg = int(msg)
```
6. 转回消息的处理.
```python
    m = re.findall(r'.{2}', str(m))
    m = map(int,m)
    m = map(lambda x:x+30,m)
    m = "".join(map(chr,m))
```

对应上述过程，散列值则对应消息摘要，A与B各自拥有一对密钥。

7. 得到A的消息摘要h(m)后，B对于得到的消息明文m的进行生成散列值，同样得到相同的散列值，即B得到的消息摘要H(m)=`25f9e`，二者相同，则说明了此信息为A所发.



## 3.部分单元测试展示



以下为使用试用数据得出的结果.

<img src="F:\learning\_networkSecurity\RSA_Hash_fig\RSA_Hash1RES1.png" alt="RSA_Hash1RES1" style="zoom: 67%;" />

结果符合题意.




## 4. 补充


> 分析并解释 《中华人民共和国电子签名法(2019修正)》修改的内容

第十一条

当事人提交的电子数据，通过电子签名、可信时间戳、哈希值校验、区块链等证据收集、固定和防篡改的技术手段或者通过电子取证存证平台认证，能够证明其真实性的，互联网法院应当确认。

影响：互联网法院认可真实的电子数据作为案件审理的证据，这些电子数据可以通过电子签名、可信时间戳、哈希值校验、区块链等技术手段进行真实性确认。




更多详细情况可以直接进行文件测试。