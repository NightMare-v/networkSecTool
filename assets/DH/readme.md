[toc]

## 1.作业基本信息



| 这个作业的目标       | 1.实现Github上提交文件<br>2.接口的导入及其使用<br>3.文件格式的规范化 |
| -------------------- | ------------------------------------------------------------ |
| Github仓库           | *[仓库链接](http://10.21.4.83:81/3120005069/ns/-/tree/main/)*      |
| 其他参考文献         | ...|



## 2.计算模块接口的设计与实现过程

### 2.1 问题需求

> 题目：编程实现 DH 密钥协商协议 
> 共同参数。素数P，P的一个生成元g 
> 1. A 随机选择一个 [1,p-1] 范围内的数`x`，计算 `X` = g^x 
> 2. B 随机选择一个 [1,p-1] 范围内的数`y`，计算 `Y` = g^y mod p, 并将结果发送给A。 
> k` = Y^x = X^y 

### 2.2 设计思路

#### 2.2.1 原理与理论基础

Diffie-Hellman密钥交换算法

+ 有两个全局公开的参数，一个素数p和一个整数a，a是p的一个原根（对于正整数gcd(a,m)=1，如果a是模m的原根，那么a是整数模m乘法群的一个生产元）；

+ 假设用户A和B希望交换一个密钥，用户A选择一个作为私有密钥的随机数XA<p，并计算公开密钥YA = a^XA mod p，A对XA的值保密存放而使YA能被B公开获得。类似地，用户B选择一个私有的随机数XB<p，并计算公开密钥YB = a^XB mod p。B对XB的值保密存放而使YB能被A公开获得。

+ 用户A产生共享秘密密钥的计算方式是K = (YB)^XA mod p。同样，用户B产生共享秘密密钥的计算是K = (YA)^XB mod p。这两个计算产生相同的结果


#### 2.2.2 内容与实现过程

1. 输入素数 p 

此时将对输入的 p 进行素数的判断

使用 `isPrime(int n)`

2. 求素数 p 的一个生成元 g

当a是p的原根，就是a^(p - 1) = 1(mod p)当且仅当指数为p-1的时候成立，则取a在[2, p-1]之间进行取值，若是其中有满足上述式子的a则放到列表中，最后在自动生成原根的时候是人为的取得最大的那个数值作为原根。

例如当p = 7时，a从2开始取值，因为2^3 = 1(mod 7),3!=6,所以2不是p的原根；

当a = 3时,3^1 = 3(mod 7),3^2 = 3(mod 7),3^3 = 6(mod 7),3^4 = 4(mod 7),3^5 = 5(mod 7),3^6 = 1(mod 7)

所以p = 7的一个原根就是3，同样的道理可以求出p的所有的原根。


使用函数 `get_generator(int p)`

```python
def get_generator(p):
    # 得到所有的原根
    # 寻找生成元a
    a = 2
    list = []
    while a < p:
        flag = 1
        while flag != p:
            if (a ** flag) % p == 1:
                break
            flag += 1
        if flag == (p - 1):
            list.append(a)
        a += 1
    return list
```

3. A与B得到通过随机生成的私钥，范围在[1,p-1]

4. 通过素数p，生成元，密钥 生成交换的密钥。

5. 进行计算交换得到的密钥与自己的密钥，得到共享秘密密钥k



以下为部分功能代码：


+ GCD 求两数最大公因子

```python
def GCD(a, b):
    if (b):
        return GCD(b, a % b)
    else:
        return a
```

+ 费马检测

```python
def ExpMod(b, n, m):
    return b ** n % m
```

+ 判断 g 为模 p 乘的生成元 `bool isPrimeRoot(g, p)`

在上述功能描述中包含选用生成元的过程。

寻找p的生成元 ，从 g 从2，3等较小的数开始进行穷举。 计算 g^n mod p ， 1<=n < p-1 的到的数据不同，g即为生成元。



## 3.部分单元测试展示



以下为求两个数最大公因子的展示

<img src="F:\learning\_networkSecurity\DH\DH1GCD1.png" alt="DH1GCD1" style="zoom: 67%;" />

以下为DH算法的完整结果展示：

<img src="F:\learning\_networkSecurity\DH\DH1RES1.png" alt="DH1RES1" style="zoom: 80%;" />

通过输入素数，找到其一个生成元，A与B各自随机生成密钥，通过素数计算出用于交换的密钥，交换密钥后计算出共享秘密密钥。



更多详细情况可以直接进行文件测试。